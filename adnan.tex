\documentstyle[11pt,fullpage,doublespace]{article}
\setstretch{1.2}

% \documentstyle[fullpage]{article}

% \oddsidemargin  0.0in
% \evensidemargin 0.0in
% \textwidth      6.50in
% \topmargin      -0.45in
% \textheight     9.0in
% \parindent      0.5in
% \footnotesep    0.25in

\author{}
\date{}

\begin{document}

\subsection*{Integrating CMOS with nanotechnology}

The reliability of the basic building blocks of logic networks---gates and 
wires---in nanotechnology is many orders of magnitude less than in CMOS.

von Neumann~\cite{neumann_noisy} is credited with first developing 
the theory of building logic networks that reliably compute
Boolean functions using unreliable components.  

The model underlying von Neumann's research consists of 
a fixed library of gates, each with an error probability of $\epsilon$;
errors were assumed to be statistically independent.
von Neumann's goal was to determine when a network could compute a 
Boolean function with a probability of error less than $\delta$.

von Neumann gave two constructions for building reliable networks:
one based on ``single lines,'' the other based on ``multiple lines.''

\subsection*{The single line model}

In this model the output of each gate is a single
wire, and which automatically lower bounds the value of $\delta$ to be not less
than $\epsilon$.  von Neumann showed that by suitably designing 
the network, it was possible to keep $\delta$ close to $\epsilon$,
when $\epsilon < 1/6$.  His construction made use of
a ``majority organ'' which takes 3 Boolean-valued
inputs and returns their majority; the majority organ itself is made
out of unreliable gates.  The proof of correctness uses an
iterative analysis of the error probabilities of the signals internal
to the network. 
In particular, the error probability is bounded by $\sqrt((1-6\epsilon)/(1-2\epsilon))$.  

von Neumann's construction was exponential in the size of the circuit.
Pippenger~\cite{pippenger-noisy-85} gave a construction for building
reliable single line networks from unreliable gates
that for almost all functions $f$ that resulted in a circuit that was only 
a constant factor larger than the smallest possible circuit built out of ideal gates
for $f$.  However, Pippenger's construction has a huge multiplicative 
constant---roughly $8^{17}$.   Gal~\cite{gal-noisy-91} later proved
that any Boolean function that can be computed by a network of 
$c$ gates could be reliably computed by a network with $O(c \log c)$ gates,
and that certain functions, notably parity, required $\Omega( c \log c )$ gates.

\subsection*{The multiple line model}

The multiple line model removes the lower bound on $\delta \geq \epsilon$ by 
carrying multiple copies of a signal as a bundle of $N$ wires, where $N$ is a large
integer---if the majority of the wires  are $1(0)$, then the signal is a $1(0)$.
von Neumann gave a construction of a multiple line network from a given single line network
which made extensive use of majority detectors.  von Neumann was able to show 
that for this construction, if $\epsilon < 0.0107$, then the probability of the 
multiple line network would compute the correct result with probability of error
no more than $6.4/\sqrt(N) \cdot 10^{-8.6 N / 10000}$. For $1000$ lines per bundle,
this evaluates to $0.03$, which is rather poor.  For 25000 lines per bundle
the probability of error is no more than $1.2 \cdot 10^{-23}$, which is very good.

\subsection*{Limitations of the theoretical results}

The primary limitation of the computations above lies in their huge computational
complexity.  Another significant limitations include the assumption that gates
fail independently, and that all gates have the same error probability.
Finally, the analysis is asymptotic and for the worst-case; we care about 
concrete functions.

\subsection*{Existing approaches to coping with noisy gates}

Goldtein and Budiu~\cite{goldstein-nano-03} propose overcoming the unreliable nature of components
in nanotechnology by using an FPGA-like architecture for implementing logic
functions.  The architecture consists of a large ensemble of configurable logic
blocks (CLBs).  These CLBs are tested using built-in self test (BIST), and 
faulty blocks are discarded, leaving the reliable ones for implementing the functions.

We have several criticisms of this approach.  One is that the yield on
nanodevices is so low (defect rates of the order of 5\% are reported), that the
CLB yield will be near zero.  In addition, soft-errors cannot be corrected for
in this approach.  Finally, it requires running complex FPGA mapping algorithms
per implementation, rather than per design.

\subsection*{Our approach}

% Our approach builds on the theory developed by von Neumann and Pippenger.  

We propose to overcome the reliability limitations of nanotechnology
by doing design in a hybridization of nanotechnology and CMOS.  
Such an approach allows us, for example, to overcome the limitation of 
Goldstein and Mudiu's approach, by raising the yield on CLBs.   

We will develop synthesis procedures which can automatically
compute the optimum trade-off between cost and reliability in a mixed
design.  The synthesis procedures of von Neumann and Pippenger are
are not directly usable, because of their computational complexity, focus on general 
functions, and assumptions regarding gates.  Technology constraints from mixing nanotechnology and 
CMOS also need to be taken into consideration.

We will develop our synthesis procedures around concrete examples, 
rather than asymptotic families of functions. 

We are targeting microprocessors and FPGAs as driver applications
for mixed implementation in  nanotechnology and CMOS.  
For microprocessors, on-chip memory arrays (caches, TLBs, register files)
 use 90\% of the devices and a majority of the power.  Nanotechnology
is ideally suited to the implementation of memory, because of
density and regularity, and thus memory arrays will be a particular
focus of research.  For FPGAs, we will explore the trade-offs between making 
individual CLBs more reliable, and having more redundant CLBs. 

\bibliographystyle{plain}
\bibliography{/home/adnan/references/adnan_refs}

\end{document}
